function [varargout] = get_jam_level(tv_power, tv_haat, channel, cr_haat, cr_dist_to_tx)
%   function [rp beta r_array new_powers old_powers] = get_jam_level(tv_power, tv_haat,
%   channel, cr_haat)
%
%   tv_power - transmission power of the TV tower in Watts
%   tv_haat - HAAT of the TV tower in meters
%   channel - transmission channel
%   cr_haat - secondary's HAAT in meters
%
%   rp - distance at which the TV SNR is 18dB in a clean channel
%   beta - percentage of old rate the secondaries will get
%   r_array - array of distances (to TV tower) considered
%   new_powers - new power assigned (based on r_array)
%   old_powers - old power assigned (based on r_array)
%
%   NOTE: if cr_haat = 0, the function will return length(r_array)
%
%   NOTE 2: Now returns W/km^2 rather than W/point -- well, it will soon
%
%   ASSUMES:
%    - Distance to CR's own transmitter is 1 km 

TNP = get_simulation_value('TNP');
rp = get_effective_radius(tv_power/1e3, channel, tv_haat, 10^(18/10)*TNP);
spacing = 10; % was 20 in old data



r_array = (rp+14.4:spacing:rp+220);
theta_spacing = spacing;
if (cr_haat == 0)
    varargout = {length(r_array)};
    return;
end


% cr_dist_to_tx = 1; % km
% area/tower = people/tower / (people/area)
tower_area = p / pop_density


% Make our secondaries

circ = 2*pi*r_array;
num_theta = ceil(circ/theta_spacing);
num_points = sum(num_theta);
r = zeros(1, num_points);
theta = zeros(1, num_points);
r_index = zeros(size(r_array));
for i = 1:length(r_array)
    if i > 1
        r_index(i) = r_index(i-1) + num_theta(i-1);
    else
        r_index(i) = 1;
    end
    
    r(r_index(i):r_index(i)+num_theta(i)-1) = r_array(i);
    theta_array = linspace(0, 2*pi, num_theta(i)+1);
    theta_array = theta_array(1:end-1);
    theta(r_index(i):r_index(i)+num_theta(i)-1) = theta_array;
end
dist_to_tv_rx = polar_distance(r, rp, theta, 0);
rp_fractions = apply_path_loss(1, channel, cr_haat, dist_to_tv_rx);


% ring_areas = outer_area - inner_area
r_outer = [r_array+spacing/2];
r_inner = [rp r_array(1:end-1)+spacing/2];
ring_areas = pi*r_outer.^2 - pi*r_inner.^2;
tower_areas = ring_areas ./ num_theta;


% Find naive/ideal powers
max_noise = TNP;
max_power = zeros(size(r_array));
for i = 1:length(r_array)
    total_fractions = sum(rp_fractions(r_index(i):end));    % fraction from him and outsiders
    max_power(i) = max_noise / total_fractions;
end

% What's the old rate they're getting?
signal = apply_path_loss(1, channel, cr_haat, cr_dist_to_tx);
old_rates = log2(1 + signal.*max_power / TNP);


beta_min = 0;
beta_max = 1;

old_powers = max_power;
tv_signal = apply_path_loss(tv_power, channel, tv_haat, rp);
target_snr = 15;

beta_stop = 0;
iterations = 0;
max_iterations = 20;
while (~beta_stop && iterations < max_iterations)
    beta = mean([beta_min, beta_max]);
    target_rate = beta * old_rates;
    
    new_powers = ((2.^(target_rate) - 1) .* (TNP) ) / signal;


    new_powers = min(new_powers, beta*old_powers);
    new_powers(end-1:end) = ones(2,1)' * new_powers(end-2);
    
    
    
    new_powers_long = max_power_to_powers(new_powers, r_index, num_points);
    total_tv_interference = sum(new_powers_long'.*rp_fractions);
    tv_snr_at_rp = 10*log10( tv_signal / (total_tv_interference + TNP) );
    
    if (tv_snr_at_rp > target_snr)
        beta_min = beta;
    else
        beta_max = beta;
    end
    beta_stop = ( (tv_snr_at_rp - target_snr) < 0.05) && (tv_snr_at_rp - target_snr) > 0;
    
    iterations = iterations + 1;
end

if (iterations == max_iterations)
    display('Warning: hit the maximum number of iterations before converging');
end


varargout = {rp beta r_array new_powers./tower_areas old_powers./tower_areas};



end








function [powers] = max_power_to_powers(max_power, r_index, num_points)
powers = zeros(1, num_points);
r_index = [r_index, num_points + 1];
for i = 1:length(r_index)-1
    powers(r_index(i):r_index(i+1)-1) = max_power(i);
end
end